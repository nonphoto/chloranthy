<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script type="module" src="../index.js"></script>
  </head>
  <body>
    <style>
      html {
        font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue",
          sans-serif;
        font-size: 20px;
      }
      body {
        margin: 0;
        padding: 0;
      }
      #parent {
        background-color: #dde;
        width: 100px;
        height: 100px;
      }
      #child {
        background-color: #aab;
        width: 50px;
        height: 50px;
        position: relative;
        top: 10px;
        left: 10px;
      }
      main[data-layout] #parent {
        width: 200px;
        height: 200px;
        position: relative;
        top: 100px;
        left: 100px;
      }
    </style>
    <script scoped type="module">
      import sync, { cancelSync } from "https://cdn.skypack.dev/framesync";
      import { animate, mix } from "https://cdn.skypack.dev/popmotion";
      import {
        layoutNode,
        updateProjectionStyle,
      } from "https://cdn.skypack.dev/projection@2.0.0-alpha.3";

      function pixelsToPercent(pixels, min, max) {
        return (pixels / (max - min)) * 100;
      }

      function mixRect(prev, next, p) {
        return {
          top: mix(prev.top, next.top, p),
          left: mix(prev.left, next.left, p),
          right: mix(prev.right, next.right, p),
          bottom: mix(prev.bottom, next.bottom, p),
        };
      }

      function animateRect(rect, options = {}) {
        const result = stream.data(stream.sample(rect));
        stream((prev) => {
          if (prev && rect()) {
            animate({
              ...options,
              from: 0,
              to: 1,
              onUpdate: (p) => void result(mixRect(prev, rect(), p)),
            });
          } else {
            result(rect());
          }
          return rect();
        }, stream.sample(rect));
        return result;
      }

      function getLayoutRect(element, trigger) {
        const rect = stream.data();
        const childTrigger = stream.data();
        stream.on([element, trigger], () => {
          if (element()) {
            element().style.transform = "";
            childTrigger(null);
            rect(element().getBoundingClientRect());
          }
        });
        return [rect, childTrigger];
      }

      function projectElement(
        element,
        targetRect,
        layoutRect,
        parent,
        borderRadius = 16
      ) {
        return stream(() => {
          if (element()) {
            const projection = layoutNode(
              {
                onProjectionUpdate: () =>
                  updateProjectionStyle(element(), projection),
              },
              typeof parent === "function" ? parent() : undefined
            );
            stream.cleanup(() => {
              projection.destroy();
            });
            stream(() => {
              if (layoutRect()) {
                projection.setLayout(layoutRect());
              }
            });
            stream.on([targetRect, layoutRect], () => {
              if (targetRect()) {
                projection.setTarget(targetRect());
                element().style.borderRadius = `${pixelsToPercent(
                  borderRadius,
                  targetRect().left,
                  targetRect().right
                )}% / ${pixelsToPercent(
                  borderRadius,
                  targetRect().top,
                  targetRect().bottom
                )}%`;
              }
            });
            return projection;
          }
        });
      }

      export default () => {
        const [toggle, setToggle] = stream.create(false);
        const click = () => {
          setToggle(!stream.sample(toggle));
        };
        return {
          click,
          toggle,
          projectElement,
          getLayoutRect,
          animateRect,
          layoutTrigger: toggle,
        };
      };
    </script>
    <main bind-on-click="click" bind-attr-data-layout="toggle">
      <script scoped type="module">
        export default ({
          projection,
          projectElement,
          getLayoutRect,
          animateRect,
          layoutTrigger,
        }) => {
          const element = stream.data();
          const [layoutRect, childTrigger] = getLayoutRect(
            element,
            layoutTrigger
          );
          const targetRect = animateRect(layoutRect);
          const childProjection = projectElement(
            element,
            targetRect,
            layoutRect,
            projection
          );
          return {
            parentElement: element,
            projection: childProjection,
            layoutTrigger: childTrigger,
          };
        };
      </script>
      <div id="parent" bind-ref="parentElement">
        <script scoped type="module">
          export default ({
            projection,
            projectElement,
            getLayoutRect,
            animateRect,
            layoutTrigger,
          }) => {
            const element = stream.data();
            const [layoutRect, childTrigger] = getLayoutRect(
              element,
              layoutTrigger
            );
            const targetRect = animateRect(layoutRect);
            const childProjection = projectElement(
              element,
              targetRect,
              layoutRect,
              projection
            );
            return {
              childElement: element,
              projection: childProjection,
              layoutTrigger: childTrigger,
            };
          };
        </script>
        <div id="child" bind-ref="childElement"></div>
      </div>
    </main>
  </body>
</html>
